#!/usr/bin/env python3

import os
import sys
import re
import subprocess

mode_debug = False

# ----
# CUSTOMIZABLE OPTIONS
# ----

# error messages to print
error_usage = "usage: md_export path_to_file.md"
error_shell = "- ERROR. use d to enable debug mode."

# templates
template_path = f"{os.path.dirname(os.path.realpath(__file__))}/templates/"
template_recent = "_recent.yaml"

# default filetype
filetype_default = "pdf"

# shell commands
def cmd_openEditor(path):
    return f"vim {path}"
def cmd_pandoc(fIn, fOut, template):
    return f"pandoc --pdf-engine=xelatex --metadata=classoption:fleqn -s -o {fOut} {fIn} {template}"
def cmd_openFile(path):
    return f"ql {path}"
def cmd_dot(img):
    return f"dot -Tsvg -O {img}"
def cmd_inkscape(img):
    return f"inkscape -D -z {img}.svg -o {img}.pdf --export-latex"

# temporary files
temp_path = f"{os.path.dirname(os.path.realpath(__file__))}/temporary/"
temp_filename = "temp_md"

# ---
# SPECIAL CONTENT
# content that needs to be modified to be exported correctly
# ---

# GRAPHVIZ
graphviz_filename = "graphviz"
def graphviz_latexfigure(imgNum):
    return f"""\\begin{{figure}}[h!]
    \\centering
    \\input{{{temp_path}{graphviz_filename}{imgNum}.pdf_tex}}
\\end{{figure}}"""
graphviz_widthregex = r"\\setlength\{\\unitlength\}\{(\d+\.?\d*bp)\}"
def graphviz_width(suggested):
    return f"\\ifdim {suggested}>\\textwidth\\textwidth\\else {suggested}\\fi"
# handler
# converts graphviz to vector images and returns replace string
def handleGraphviz(match, idx):
    path = f"{temp_path}{graphviz_filename}{idx}"
    # creates file with block content
    with open(path, 'w') as graphvizFile:
        graphvizFile.write(f"\n{match.group(1)}")
    # exports graphviz as .svg
    imageName = f"{graphviz_filename}{idx}"
    imagePath = f"{temp_path}{imageName}"
    shellCommand(cmd_dot(imagePath))
    shellCommand(cmd_inkscape(imagePath))
    # open exported .pdf_tex file and adjust references to created .pdf files by adding the correct path
    # and save new file as .pdf_tex.tex
    with open(f"{imagePath}.pdf_tex", 'r') as inkscapeFile:
        with open(f"{imagePath}.pdf_tex.tex", 'w') as inkscapeFileCorrected:
            correctedString = re.sub(imageName, imagePath, inkscapeFile.read())
            # check svg width inkscape suggested
            imageWidthMatch = re.search(graphviz_widthregex, correctedString)
            # adjust width
            correctedString = swapSubstring(correctedString, imageWidthMatch.span(1), graphviz_width(imageWidthMatch.group(1)))
            inkscapeFileCorrected.write(correctedString)
    return graphviz_latexfigure(idx)

# SPECIAL CONTENT LIST
# regex: function (handler)
# match and index is passed into handler, handler returns replace string
special_content_handlers = {
    r"```graphviz([^`]*)```": handleGraphviz
}

# ----
# FUNCTIONS
# ----

# runs command in shell, silences output if not in debug mode, notifies if errors occur
def shellCommand(command):
    output = None if mode_debug else subprocess.DEVNULL
    err = subprocess.call(command, shell=True, stdout=output, stderr=output)
    if err != 0 and not mode_debug: print(error_shell)

# swaps span in str1 with str2
def swapSubstring(str1, span, str2):
    return str1[:span[0]] + str2 + str1[span[1]:]

# template and option ((x) edit, (o)pen, (d)ebug) picker
def pickTemplate(maxN):
    i = input("> ")
    try: 
        # template number
        pick = int(i[:re.search(r"^\d*", i).end()])
        # check for 'o' (open)
        shouldOpen = re.search(r"^\d*(x|d)*o", i)
        # check for 'x' (edit)
        edit = re.search(r"^\d*(o|d)*x", i)
        # check for 'd' (debug)
        if re.search(r"^\d*(x|o)*d", i):
            global mode_debug
            mode_debug = True
            print("- debug mode enabled.")
        # filetype other than default
        filetype = re.search(r"[.](.*)$", i)
        if pick > 0 and pick <= maxN:
            return pick, edit, shouldOpen, filetype_default if filetype is None else filetype.group(1)
        else:
            raise ValueError('option out of bounds.')
    except ValueError:
        print(f"  please pick one of the given options (1...{maxN}).")
        return pickTemplate(maxN)

# template editor
def customTemplate(fromTempl, filetype):
    print("\n- custom template")
    
    # copy editing template into recent
    templString = open(f"{template_path}{fromTempl}", 'r').read()
    templRecent = open(f"{template_path}{template_recent}", 'w')
    templRecent.write(templString)
    templRecent.close()

    # open recent in editor
    subprocess.call(cmd_openEditor(template_path + template_recent), shell=True)
    # save template with valid filename if desired
    print(f"- hit return to create .{filetype} or enter name to save template")
    newTemplName = input("> ")
    if newTemplName != "" :
        validName = "".join(re.findall(r"[a-zA-Z\d\-\_]*", newTemplName)) + ".yaml"
        newTempl = open(f"{template_path}{validName}", 'w')
        newTempl.write(open(f"{template_path}{template_recent}", 'r').read())
        newTempl.close()

# extract special content and pass to handlers, export file
def createFile(templ, filetype, shouldOpen):
    # retrieve md content
    mdFileContent = open(sys.argv[1], 'r').read()

    # handle special content
    for regex in special_content_handlers.keys():
        idx = 0
        match = re.search(regex, mdFileContent, re.DOTALL)
        while match:
            mdFileContent = swapSubstring(mdFileContent, match.span(), special_content_handlers[regex](match, idx))
            idx += 1
            match = re.search(regex, mdFileContent, re.DOTALL)

    # save new file at temporary location
    exportMDName = f"{temp_path}{temp_filename}.md"
    with open(exportMDName, 'w') as newMDFile:
        newMDFile.write(mdFileContent)
    
    # create pdf
    print(f"- creating .{filetype} ...")
    shellCommand(cmd_pandoc(exportMDName, f"{sys.argv[1][:-3]}.{filetype}", template_path + templ))
    print("- done.\n")
    # optionally open pdf
    if shouldOpen:
        shellCommand(cmd_openFile(f"{sys.argv[1][:-3]}.{filetype}"))
    # delete all temporary files if not in debug mode
    if not mode_debug:
        for f in os.listdir(temp_path):
            os.remove(os.path.join(temp_path, f))
    exit()

if __name__ == "__main__":
    args = sys.argv
    # check for correct number of arguments
    if len(args) != 2:
        print(error_usage)
        exit()
    # check if input file is .md
    if not re.search(r".*\.(md|MD)$", args[1]):
        print(error_usage)
        exit()

    # print templates
    print("\n- templates:")
    templates = []
    for (_, _, filenames) in os.walk(template_path):
        for filename in sorted(filenames):
            if re.search(r".*\.yaml$", filename):
                templates.append(filename)
                print(f"  [{len(templates)}]: {filename[:-5]}")
    
    # pick template
    print(f"- pick template (add 'x' to edit, 'o' to open file after creation, 'd' for debug mode, '.abc' to export .abc instead of .{filetype_default})")
    option, shouldEdit, shouldOpen, filetype = pickTemplate(len(templates))
    if shouldEdit:
        customTemplate(templates[option - 1], filetype)
        createFile(template_recent, filetype, shouldOpen)
    else:
        createFile(templates[option - 1], filetype, shouldOpen)

